---
title: "Analysis"
output: html_notebook
editor_options:
  chunk_output_type: inline
---

# Analysis

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      comment = "#>",
                      collapse = TRUE)
knitr::opts_knit$set(root.dir = '../')
```

## Setup

Load reqired packages

```{r load packages for data processing, hide=TRUE}
#data wrangling and visualization
library(tidyverse)
library(ggplot2)
library(ggthemes)
library(ggforce)
library(ggridges)
library(ggsci)
library(wesanderson)
library(gghighlight)
library(GGally)
library(tidygraph)
library(ggraph)
library(graphlayouts)

#network analysis
library(network)
library(igraph)

#GLMM
library(lme4)
library(car)


```
```{r load packages for data analysis, hide=TRUE}
library(lme4)
library(MuMIn)
library(car)
```

## Data overview

load relatedness results

```{r import relatedness results}
load("data/relate_results.RData")
load("data/sample_Info.RData")
load("data/data_overview.RData")

```

```{r}
str(relate_results)
```




load association data
```{r import association data}
load("data/co-roosting-network.RData")
str(network)

```



## network of relatedness
let's try to visualize the relatedness relationships with network, in which each individual is a node and edges show genetic relationship

```{r}
#select relatedness data (ngsrelate rab) from mpala
#relatedness_rab <- relate_results%>% subset(a_Group %in% c("mpala", "mpala_chicks") & b_Group %in% c("mpala", "mpala_chicks")) %>% select(ID_a, ID_b, rab)

relatedness_rab <- relate_results %>% select(ID_a, ID_b, rab)

#create node list
ID_a <- relatedness_rab %>% distinct(ID_a) %>% rename(label = ID_a)

ID_b <- relatedness_rab %>% distinct(ID_b) %>% rename(label = ID_b)

nodes <- full_join(ID_a, ID_b, by = "label")

nodes <- nodes %>% rowid_to_column("id")

nodes <- left_join(nodes, sample_info, by = c("label"= "ID"))

nodes

```


```{r}
#create edge list
edges <- relatedness_rab %>% left_join(nodes, by = c("ID_a" = "label")) %>% rename(id_a = id)

edges <- edges %>% left_join(nodes, by = c("ID_b" = "label")) %>% rename(id_b = id) %>% rename (weight = rab)

edges <- select(edges, id_a, id_b, weight)

edges
```


using igraph

tidygraph and ggraph


```{r}
#rab_tidy <- tbl_graph(nodes = nodes, edges = edges, directed = FALSE)

#theme_set(dark_theme_classic())

rab_igraph <- graph_from_data_frame(d = edges, vertices = nodes, directed = FALSE)

#create a cutoff under which edges are not displayed or manually set cutoff to 0.1
cut.off <- mean(edges$weight) 
net.sp <- delete_edges(rab_igraph, E(rab_igraph)[weight<0.1])

#generate colours based on sex
V(net.sp)$shape <- case_when(V(net.sp)$sex == "f" ~ "circle",
                                V(net.sp)$sex == "m" ~ "triangle")

Ten_colors <-  scales::viridis_pal()(10)

#generate shape based on group
V(net.sp)$color <- case_when(V(net.sp)$Group_ID == "mpala" ~ Ten_colors[1],
                                V(net.sp)$Group_ID == "mpala_chicks" ~ Ten_colors[2],
                                V(net.sp)$Group_ID == "wing_tags" ~ Ten_colors[3],
                                V(net.sp)$Group_ID == "5509" ~ Ten_colors[4],
                                V(net.sp)$Group_ID == "5931-5938" ~ Ten_colors[5],
                                V(net.sp)$Group_ID == "dump" ~ Ten_colors[6],
                                V(net.sp)$Group_ID == "wt025" ~ Ten_colors[7],
                                 V(net.sp)$Group_ID == "5512" ~ Ten_colors[8],
                                 V(net.sp)$Group_ID == "RRWB" ~ Ten_colors[9],
                                 V(net.sp)$Group_ID == "ROOP" ~ Ten_colors[10]
                             )

ggraph(net.sp, layout = "stress",bbox = 50) + 
 # geom_node_point() +
  geom_edge_link2(aes(width = weight), alpha = 0.2) + 
  scale_edge_width(range = c(0, 3)) +
  geom_node_point(color=V(net.sp)$color, shape = V(net.sp)$shape, size= 2)  +
  labs(edge_width = "rab", color = "Group_ID", shape = "sex") +
  theme_graph()+
  theme(legend.position = "bottom") 




```

```{r}
group <- c("mpala" , "mpala_chicks","wing_tags","5509" , "5931-5938", "dump" ,"wt025","5512" ,"RRWB","ROOP")
ID <- (1:10)
sex <- c("male" , "female","male", "female","male", "female","male", "female","male", "female" )

test <- as.data.frame(cbind(group, ID, sex))

ten_colors_sorted <- c(Ten_colors[4],Ten_colors[8],Ten_colors[5],Ten_colors[6],Ten_colors[1],Ten_colors[2],Ten_colors[10],Ten_colors[9], Ten_colors[3], Ten_colors[7])

theme_set(theme_classic())

ggplot(test, aes(x=group, y=sex)) +
  
  geom_point(aes(color=group, shape = sex)) +
  
  scale_color_manual(values = ten_colors_sorted)
  
  

```





```{r}
# Community detection (by optimizing modularity over partitions):
clp <- cluster_optimal(net.sp)
class(clp)


V(net.sp)$community <- clp$membership

V(net.sp)$community2 <- case_when(V(net.sp)$community == "3" ~ Ten_colors[1],
                                V(net.sp)$community == "4" ~ Ten_colors[3],
                                V(net.sp)$community == "2" ~ Ten_colors[7],
                                V(net.sp)$community == "1" ~ Ten_colors[2],
                                V(net.sp)$community == "5" ~ Ten_colors[10],
                                V(net.sp)$community == "6" ~ Ten_colors[9],
                                V(net.sp)$community == "7" ~ "brown")


ggraph(net.sp, layout = "stress",bbox = 50) + 
  
  geom_edge_link(aes(width = weight), alpha = 0.2) + 
  scale_edge_width(range = c(0, 3)) +
  geom_node_point(color=V(net.sp)$community2, shape = V(net.sp)$shape, size= 5) +
  geom_node_point(color=V(net.sp)$color, shape = V(net.sp)$shape, size= 3) +
  geom_node_text(aes(filter = (label == "  "), label = label, size = degree(net.sp))) +
  labs(edge_width = "rab", color = "Group_ID", shape = "sex") +
  theme_graph()+
  theme(legend.position = "bottom") 

```


try better visualization with "backbone" following the tutorial http://mr.schochastics.net/netVizR.html

```{r}
bb <- layout_as_backbone(rab_igraph,keep = 0.1)
E(rab_igraph)$col <- FALSE
E(rab_igraph)$col[bb$backbone] <- TRUE

ggraph(rab_igraph,layout = "manual",x = bb$xy[,1],y = bb$xy[,2])+
  

  geom_edge_link(aes(width = weight), alpha = 0.2) + 
  scale_edge_width(range = c(0, 3)) +
  
  geom_node_point(aes(fill = Group_ID),shape = 21)+
  scale_fill_brewer(palette = "Set1")+
  theme_graph()+
  theme(legend.position = "none")



```


#association network

extract the networks for the six different seasons

```{r}
#get long format of associations from network data

for(i in 1:6) {
  
 assoc_network <- network[[i]] %>% as.data.frame %>% tibble::rownames_to_column() %>% tidyr::pivot_longer(-rowname) %>% filter(rowname != name)

names(assoc_network) <- c("id_a","id_b",paste("assoc", i, sep = "_")) 

assign(paste("assoc_nw", i, sep = "_"), assoc_network)
}

#assoc_nw_1 <- network[[1]] %>% as.data.frame %>% tibble::rownames_to_column() %>% tidyr::pivot_longer(-rowname) %>% filter(rowname != name)

#names(assoc_nw_1) <- c("id_a","id_b","assoc_1") 


#combine association data in one table

assoc_nw <- full_join(assoc_nw_1, assoc_nw_2, by = c("id_a", "id_b"))

assoc_nw <- full_join(assoc_nw, assoc_nw_3, by = c("id_a", "id_b"))

assoc_nw <- full_join(assoc_nw, assoc_nw_4, by = c("id_a", "id_b"))

assoc_nw <- full_join(assoc_nw, assoc_nw_5, by = c("id_a", "id_b"))

assoc_nw <- full_join(assoc_nw, assoc_nw_6, by = c("id_a", "id_b"))

```

#statistical analysis: GLMM
Run general and generalized linear mixed models with the package `lme4`.

Model formular to test influence on relatedness: is relatedness influenced by group membership and is this different for males and females?
full model

response: dyadic relatedness (need to run for every relatedness estimator)
fixed effects:
main predictors: association (covariate, alternative: group_dyad (factor)) and sex (factor). Factor with k levels is coded with k-1 dummy predictors.
fixed control: group membership
random effect: 
random intercept: individual/identity, group?
coverage? either include coverage as a predictor or use weighted regression
for association: test 
test interaction of coverage and sex (for interaction of 2 factors, they need to be fully crossed (i.c. each combination of their levels exists))
and interaction of dyad_sex and dyad_group

full model (response ~ test predictors + control predictors): relatedness = group_dyad + sex_dyad + coverage + sex_dyad:coverage

null model (response ~ control predictors): relatedness = coverage 


## Check the data

```{r}
str(relate_results)
```

inspect the data:

inspect the distribution of the response: relatedness
```{r}
hist()
```

is there a need for transformation?

inspect the distribution of the predictors: (i) association (covariate)
```{r}
hist()
```

alternatively (i) group_dyad (factor with 2 levels: intragroup, intergroup)


(ii) sex (factor with 3 levels: male-male, male-female, female-female)
```{r}
hist()
```

(iii) coverage/nbSNP/nSites
```{r}
hist()
```
 
 or do all at once
```{r}
test.vars <- c("predictor1", "predictor2", "predictor3")

par(mfrow = c(2,2))

for(i in 1:length(test.vars)){
	hist(data[,test.vars[i]], main = test.vars[i])
	}
```


is there a need to transform any of the variables?

if need to transfrom:
check if log is good
min(predictor)
hist(log(data$predictor))
data$log_predictor <- log(data$predictor)

plot interacting predictors
```{r}
plot(data$log_predictor, data$predictor2)
```

to include the interaction of 2 covariates we need to z-transform them 
Z-transform all covariates to a mean of 0 and a sd of 1 prior to fitting the model to allow easier interpretation of the estimates. But still need to inform about original means and sd.

```{r z-transformation}
pred.vars <- c("log.predictor", "predictor2", "predictor3)
xx <- data.frame(scale(data[,pred.vars]))
names(xx) <- paste("z", names(xx), sep = "_"
```

or for each individually
relate_results$rab_z <- as.vector(scale(relate_results$rab))
relate_results$pi_HAT_z <- as.vector(scale(relate_results$pi_HAT)) 
relate_results$Normalized2AlleleDifference_z <- as.vector(scale(relate_results$Normalized2AlleleDifference))
relate_results$coverage_z <- as.vector(scale(relate_results$coverage))
relate_results$nbSNP_z <- as.vector(scale(relate_results$nbSNP))
relate_results$nSites_z <- as.vector(scale(relate_results$nSites))

check whether z-transformation worked
```{r}
apply(X = xx, MARGIN = 2, FUN = mean)
apply(X = xx, MARGIN = 2, FUN = sd)

data <- data.frame(data, xx)
```


check correlations among the predictors

```{r}
pred.vars <- c()

vars.cor <- cor(data[,pred.vars])

max(abs(vars.cor[upper.tri(vars.cor)]))
```


## fit the model

lmer(relatedness ~ association + group + sex + (1|ID_a) + (1|ID_b), data = relate_results, REML = F)


```{r full glmm}
res <- lm(response ~ predictor1 + predictor2 + predictor3 + predictor1:predictor3, weights = weight, data = data)
#or
res_full <- lm(response ~ predictor1*predictor3 + predictor2, data)
```

for hypothesis testing, we also need a null model
```{r null glmm}
res_null <- 
```

Build a reduced model without the important factor
```{r reduced model}
red <- lm(response ~ covariate + factor, data = data)
```



testing this
```{r}
model_simpletest <- lmer(rab_z ~ dyad_group + dyad_sex + (1|ID_a) + (1|ID_b), data = relate_results, REML = F)
model_simpletest
```



## model diagnostics

### check of assumptions

normality of residuals

```{r}
residuals(res)

hist(residuals(res), probability = T)

x <- seq(from = min(residuals(res)), to = max(residuals(res)), length.out = 100)

lines(x = x, y = dnorm(x, mean = 0, sd = sd(residuals(res))))
```

qqplot
```{r}
#in an indeal case, all points would fall on a straight line
qqnorm(residuals(res))
qqline(residuals(res))
```

homogeneity of residuals

```{r}
#no obvious pattern should be visible
fitted(res)

plot <- (x = fitted(res), y = residuals(res), pch = 19)
```

### model stability


fitted values (DFFit)

```{r}
dffits(res) #standardized DFFit-values

max(abs(dffits(res))) #absolute value >~2 is a reason to worry

hist(dffits(res))
```

model estimates (DFBeta)

```{r}
dfbeta(res) #unstandardized DFBeta, should reveal little variation

xx <- cbind(res$coefficients, res$coefficients +
              t(apply(X = dfbeta(res), MARGIN = 2, FUN = range)))

colnames(xx) <- c("orig", "min", "max")
round(xx, 5)
```

```{r}
#standardized DFBeta
dfbetas(res) #absolute values larger than 1 or 2 are a reason to worry
```

Cook's distance
```{r}
max(cooks.distance(res)) #check recommended thresholds in Mundry handout 02b
```

leverage
```{r}
max(as.vector(influence(res)$hat))
```

Check for collinearity with Variance Inflation Factors (VIF) requires `car` package.
for categorical predictors with more than two levels we use the modification Generalized VIF (GVIF)
interactions frequently lead to large VIF, we exclude the interactions before
```{r}
res_vif <- lm(response ~ predictor1 + predictor2 + predictor3, data)
vif(res_vif) #check recommended thresholds in Mundry handout 03b
```

to interpret like standard VIF
```{r}
vif(res)[,3]^2
```


plot various diagnostics
SEE FUNCTION IN MUNDRY SCRIPT 02b



## Inference

compare full model and reduced model using the function `anova´.

could also compare to null model. When using weighted model, check results of unweighted model. 

```{r}
as.data.frame(anova(red, res, test = F) #simple model first
```
if significant, this means that factor that was reduced has a significant effect.


inspect results of full model
```{r}
summary(res_full)
```

only if full model significant, start looking at individual predictors!

results for individual predictors
```{r}
summary(res)$coefficients
```

safe results
```{r}
write.table(summary(res)$coefficients, file = "results/glmm/fullmodel_results.txt", row.names = T, col.names = T, sep = "\t")
```


Overall effect size
```{r}
summary(res)$adj.r.squared
```

effect sizes for the individual effects with the function 'drop1', which drops each term from the model (one at a time) and uses and F-test to compare the full with the respective reduced model.
```{r}
xx <- drop1(res)$RSS

(xx[-1]-xx[1])/xx[-1]
```

test effect sizes
```{r}
drop1(res, test = "F")
```

obtain confidence intervals
```{r}
confint(object = res)
```

combine confidence intervals with original estimates
```{r}
round(cbind(orig = coefficients(res), confint(object = res)), digits = 3)
```

FOR PLOTTING SEE Mundry script 04b




Protection agains multiple testing with full-null model comparison


Tests of the individual predictors


Measuring effect isze of individual predictors






vgl. Dal Pesco et al. 2021

Check for need of random slopes

























