[["index.html", "Guineafowl-lcWGS Notebook Project Notebook 1 Intro 1.1 Dependencies", " Guineafowl-lcWGS Notebook Project Notebook Gisela H. Kopp 2021-09-22 1 Intro Hello, this is a minimal {bookdown} diary-style notebook to document this project. The documentation of this project is broken down into several chunks: 1 Intro: General intro to the project (you are looking at this right now) 2 Project development: Here I keep a diary of the development of the project. 3 Notes: Notes on ideas, what should be or has been read, etc. 4 Data: The data needed and compiled for the project. 5 Analysis: The analysis. (We might want to break this into several subsections) 6 References: This is where session infor and all cited sources of your project will be listed. 1.1 Dependencies To be able to use this in your own projects you will need to R as well as the {bookdown} package installed: install.packages(&quot;bookdown&quot;) Feel free to adapt this template to your needs. "],["project-development.html", "2 Project development 2.1 General idea", " 2 Project development Here I track and document the development of the project in a diary style. 2.1 General idea The general idea for this project is "],["project-notes.html", "3 Project notes 3.1 Reading (notes) 3.2 Ideas to follow up on", " 3 Project notes Here I note ideas and papers read or must read. 3.1 Reading (notes) 3.2 Ideas to follow up on "],["data.html", "4 Data 4.1 Setup 4.2 Data collection 4.3 Data processing", " 4 Data Data compiled and used in this project 4.1 Setup library(tidyverse) #&gt; -- Attaching packages ---------------------------------------------------------------------- tidyverse 1.3.0 -- #&gt; v ggplot2 3.3.2 v purrr 0.3.4 #&gt; v tibble 3.0.3 v dplyr 1.0.2 #&gt; v tidyr 1.1.2 v stringr 1.4.0 #&gt; v readr 1.3.1 v forcats 0.5.0 #&gt; -- Conflicts ------------------------------------------------------------------------- tidyverse_conflicts() -- #&gt; x dplyr::filter() masks stats::filter() #&gt; x dplyr::lag() masks stats::lag() library(ggplot2) library(ggthemes) library(ggforce) library(ggridges) library(ggsci) library(wesanderson) library(ggallin) 4.2 Data collection Group information is stored in sequenced_samples_groups.csv. sampleID_group &lt;- read.csv(&quot;vignettes/data/sequenced_samples_groups.csv&quot;, header = TRUE, sep = &quot;;&quot;, as.is = TRUE) str(sampleID_group) #&gt; &#39;data.frame&#39;: 95 obs. of 4 variables: #&gt; $ Group_ID : chr &quot;wing_tags&quot; &quot;wing_tags&quot; &quot;wing_tags&quot; &quot;wing_tags&quot; ... #&gt; $ Sample.ind.code: chr &quot;A1295&quot; &quot;A1296&quot; &quot;A1297&quot; &quot;A1298&quot; ... #&gt; $ Real.ind.code : chr &quot;W1295&quot; &quot;W1296&quot; &quot;W1297&quot; &quot;W1298&quot; ... #&gt; $ Colour_.bands : chr &quot;WT002&quot; &quot;WT003&quot; &quot;WT004&quot; &quot;WT021&quot; ... #rename Real.ind.code to ID sampleID_group &lt;- rename(sampleID_group, &quot;ID&quot; = &quot;Sample.ind.code&quot;) #only keep group and ID sampleID_group &lt;- select(sampleID_group, Group_ID, ID) str(sampleID_group) #&gt; &#39;data.frame&#39;: 95 obs. of 2 variables: #&gt; $ Group_ID: chr &quot;wing_tags&quot; &quot;wing_tags&quot; &quot;wing_tags&quot; &quot;wing_tags&quot; ... #&gt; $ ID : chr &quot;A1295&quot; &quot;A1296&quot; &quot;A1297&quot; &quot;A1298&quot; ... There are three samples that are not listed correctly and would lead to NAs in downstream analysis, so we manually adjust them here #correct sample B1299 is missing sample_info_add &lt;- data.frame (Group_ID = c(&quot;wing_tags&quot;, &quot;wing_tags&quot;, &quot;5509&quot;), ID = c(&quot;B1299&quot;, &quot;W1304&quot;, &quot;W1345&quot;)) sample_info_add #&gt; Group_ID ID #&gt; 1 wing_tags B1299 #&gt; 2 wing_tags W1304 #&gt; 3 5509 W1345 sampleID_group &lt;- rbind(sampleID_group, sample_info_add) Sex information is stored in samples_sex.csv. Sex was determined in the field and confirmed at least once with a molecular sexing method in the lab. For cases with mismatch between field and molecular sex we set the sex to undetermined. sampleID_sex &lt;- read.csv(&quot;vignettes/data/samples_sex.csv&quot;, header = TRUE, sep = &quot;;&quot;, as.is = TRUE) str(sampleID_sex) #&gt; &#39;data.frame&#39;: 133 obs. of 2 variables: #&gt; $ ID : chr &quot;A1295&quot; &quot;A1296&quot; &quot;A1297&quot; &quot;A1298&quot; ... #&gt; $ sex: chr &quot;m&quot; &quot;f&quot; &quot;m&quot; &quot;m&quot; ... merge group and sex information sample_info &lt;- full_join(sampleID_group, sampleID_sex, by = &quot;ID&quot;) str(sample_info) #&gt; &#39;data.frame&#39;: 133 obs. of 3 variables: #&gt; $ Group_ID: chr &quot;wing_tags&quot; &quot;wing_tags&quot; &quot;wing_tags&quot; &quot;wing_tags&quot; ... #&gt; $ ID : chr &quot;A1295&quot; &quot;A1296&quot; &quot;A1297&quot; &quot;A1298&quot; ... #&gt; $ sex : chr &quot;m&quot; &quot;f&quot; &quot;m&quot; &quot;m&quot; ... 4.3 Data processing 4.3.1 Sequencing data First, we load an overview of the analysed sequencing libraries. They are stored in the folder pipeline as file_list.tsv. seqlib_overview &lt;- read.delim(&quot;vignettes/data/pipeline/file_list.tsv&quot;, header = TRUE, as.is = TRUE) str(seqlib_overview) #&gt; &#39;data.frame&#39;: 238 obs. of 6 variables: #&gt; $ file_name: chr &quot;mpg_L16936-1_W1350_S1_R1_001.fastq.gz&quot; &quot;mpg_L16936-1_W1350_S1_R2_001.fastq.gz&quot; &quot;mpg_L16926-1_W1398_S2_R1_001.fastq.gz&quot; &quot;mpg_L16926-1_W1398_S2_R2_001.fastq.gz&quot; ... #&gt; $ RGID : int 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ RGLB : chr &quot;lib1&quot; &quot;lib1&quot; &quot;lib1&quot; &quot;lib1&quot; ... #&gt; $ RGPL : chr &quot;ILLUMINA&quot; &quot;ILLUMINA&quot; &quot;ILLUMINA&quot; &quot;ILLUMINA&quot; ... #&gt; $ RGPU : chr &quot;unit1&quot; &quot;unit1&quot; &quot;unit1&quot; &quot;unit1&quot; ... #&gt; $ RGSM : chr &quot;RGID1_S1&quot; &quot;RGID1_S1&quot; &quot;RGID1_S2&quot; &quot;RGID1_S2&quot; ... The information about the sampled individual, which we will later need to assign the relatedness estimation to specific individuals, is available in the file_name column. We will extract this information and put it in an extra ID column. #first need to create a new column that includes the sample ID seqlib_overview$ID &lt;- gsub(&quot;([[:alnum:]]{3}_[[:alnum:]]{6}-[[:digit:]])_([[:alnum:]]{5,7})_([[:alnum:]]{2,3}_[[:alnum:]]{2}_[[:graph:]]{12})&quot;, &quot;\\\\2&quot;, seqlib_overview$file_name) str(seqlib_overview) #&gt; &#39;data.frame&#39;: 238 obs. of 7 variables: #&gt; $ file_name: chr &quot;mpg_L16936-1_W1350_S1_R1_001.fastq.gz&quot; &quot;mpg_L16936-1_W1350_S1_R2_001.fastq.gz&quot; &quot;mpg_L16926-1_W1398_S2_R1_001.fastq.gz&quot; &quot;mpg_L16926-1_W1398_S2_R2_001.fastq.gz&quot; ... #&gt; $ RGID : int 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ RGLB : chr &quot;lib1&quot; &quot;lib1&quot; &quot;lib1&quot; &quot;lib1&quot; ... #&gt; $ RGPL : chr &quot;ILLUMINA&quot; &quot;ILLUMINA&quot; &quot;ILLUMINA&quot; &quot;ILLUMINA&quot; ... #&gt; $ RGPU : chr &quot;unit1&quot; &quot;unit1&quot; &quot;unit1&quot; &quot;unit1&quot; ... #&gt; $ RGSM : chr &quot;RGID1_S1&quot; &quot;RGID1_S1&quot; &quot;RGID1_S2&quot; &quot;RGID1_S2&quot; ... #&gt; $ ID : chr &quot;W1350&quot; &quot;W1350&quot; &quot;W1398&quot; &quot;W1398&quot; ... Next, we evaluate the quality of the data and the different sequencing approaches. An overview of the data as output from the Nextflow pipeline as of 29th July 2021 is stored in preprocessing_overview.tsv data_overview &lt;- read.delim(&quot;vignettes/data/pipeline/preprocessing_overview.tsv&quot;, as.is = TRUE) str(data_overview) #&gt; &#39;data.frame&#39;: 119 obs. of 31 variables: #&gt; $ RGSM : chr &quot;RGID1_S1&quot; &quot;RGID1_S2&quot; &quot;RGID1_S3&quot; &quot;RGID1_S4&quot; ... #&gt; $ RGID : int 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ RGLB : chr &quot;lib1&quot; &quot;lib1&quot; &quot;lib1&quot; &quot;lib1&quot; ... #&gt; $ RGPL : chr &quot;ILLUMINA&quot; &quot;ILLUMINA&quot; &quot;ILLUMINA&quot; &quot;ILLUMINA&quot; ... #&gt; $ RGPU : chr &quot;unit1&quot; &quot;unit1&quot; &quot;unit1&quot; &quot;unit1&quot; ... #&gt; $ filename_one : chr &quot;mpg_L16936-1_W1350_S1_R1_001.fastq.gz&quot; &quot;mpg_L16926-1_W1398_S2_R1_001.fastq.gz&quot; &quot;mpg_L16927-1_W1429_S3_R1_001.fastq.gz&quot; &quot;mpg_L16928-1_W1502_S4_R1_001.fastq.gz&quot; ... #&gt; $ filename_two : chr &quot;mpg_L16936-1_W1350_S1_R2_001.fastq.gz&quot; &quot;mpg_L16926-1_W1398_S2_R2_001.fastq.gz&quot; &quot;mpg_L16927-1_W1429_S3_R2_001.fastq.gz&quot; &quot;mpg_L16928-1_W1502_S4_R2_001.fastq.gz&quot; ... #&gt; $ reads_pre_trim_one : int 3844063 3360132 3034920 6695288 6040662 2842383 3879834 6087445 5686616 4107154 ... #&gt; $ reads_pre_trim_two : int 3844063 3360132 3034920 6695288 6040662 2842383 3879834 6087445 5686616 4107154 ... #&gt; $ reads_pre_trim_total : int 7688126 6720264 6069840 13390576 12081324 5684766 7759668 12174890 11373232 8214308 ... #&gt; $ reads_post_trim_one : int 3334957 3057420 2775271 6144973 5496263 2618095 3544978 5592586 5206646 3740830 ... #&gt; $ reads_post_trim_two : int 3317567 2622060 2444309 5472149 4763684 2298940 2933104 4916336 4551423 3252219 ... #&gt; $ reads_post_trim_total : int 6652524 5679480 5219580 11617122 10259947 4917035 6478082 10508922 9758069 6993049 ... #&gt; $ reads_trimmed_lost_one : int 509106 302712 259649 550315 544399 224288 334856 494859 479970 366324 ... #&gt; $ reads_trimmed_lost_two : int 526496 738072 590611 1223139 1276978 543443 946730 1171109 1135193 854935 ... #&gt; $ reads_trimmed_lost_total : int 1035602 1040784 850260 1773454 1821377 767731 1281586 1665968 1615163 1221259 ... #&gt; $ reads_trimmed_lost_total_percent : num 0.135 0.155 0.14 0.132 0.151 ... #&gt; $ reads_mapped : int 6448222 5897151 5344556 11948516 10542799 5052562 6862719 10880329 10069374 7213292 ... #&gt; $ reads_mapped_and_paired : int 6124942 4910684 4546908 10259622 8836944 4295176 5524338 9244878 8510126 6063336 ... #&gt; $ reads_unmapped : int 158628 176787 170192 251546 386867 143020 186719 234815 276382 223486 ... #&gt; $ reads_mapped_percent : num 0.975 0.97 0.968 0.979 0.963 ... #&gt; $ average_coverage : num 1.6 1.63 1.58 2.16 2.07 ... #&gt; $ average_coverarge_stdev : num 2.67 2.8 2.62 2.98 3.64 ... #&gt; $ unpaired_reads_examined_for_deduplication: int 323280 986467 797648 1688894 1705855 757386 1338381 1635451 1559248 1149956 ... #&gt; $ paired_reads_examined_for_deduplication : int 3094003 2475793 2291351 5174753 4449902 2167892 2782428 4657453 4288831 3054109 ... #&gt; $ unpaired_read_duplicated : int 66109 106320 78976 195164 185282 87774 136509 172933 169988 118239 ... #&gt; $ paired_read_duplicates : int 221442 119369 103005 260460 197926 115543 120104 206962 194659 133521 ... #&gt; $ percent_duplication : num 0.0782 0.0581 0.053 0.0595 0.0548 ... #&gt; $ sequenced_library_complexity : int 6090385 5720981 5222642 11474365 10330774 4870312 6664743 10519461 9774928 7042018 ... #&gt; $ estimated_library_complexity : int 23660823 29649178 29602264 59328308 57146455 23492191 37280729 60581428 54839066 40354282 ... #&gt; $ percent_library_sequenced : num 0.257 0.193 0.176 0.193 0.181 ... One sequencing library was resequenced in an additionl run but wrongly assigned to RGID 1, so we correct this data_overview$RGID[data_overview$filename_one == &quot;mpg_L16936-1_W1350_S1_R1_001.fastq.gz&quot;] &lt;- &quot;2&quot; #create new column that specifies if sequencing results are from original run or from resequencing data_overview &lt;- data_overview %&gt;% mutate(original_reseq = case_when(RGID == &quot;1&quot; ~ &quot;original&quot;, RGID == &quot;2&quot; ~ &quot;reseq&quot;)) #first need to create a new column that includes the sample ID data_overview$ID &lt;- gsub(&quot;([[:alnum:]]{3}_[[:alnum:]]{6}-[[:digit:]])_([[:alnum:]]{5,7})_([[:alnum:]]{2,3}_[[:alnum:]]{2}_[[:graph:]]{12})&quot;, &quot;\\\\2&quot;, data_overview$filename_one) str(data_overview) #&gt; &#39;data.frame&#39;: 119 obs. of 33 variables: #&gt; $ RGSM : chr &quot;RGID1_S1&quot; &quot;RGID1_S2&quot; &quot;RGID1_S3&quot; &quot;RGID1_S4&quot; ... #&gt; $ RGID : chr &quot;2&quot; &quot;1&quot; &quot;1&quot; &quot;1&quot; ... #&gt; $ RGLB : chr &quot;lib1&quot; &quot;lib1&quot; &quot;lib1&quot; &quot;lib1&quot; ... #&gt; $ RGPL : chr &quot;ILLUMINA&quot; &quot;ILLUMINA&quot; &quot;ILLUMINA&quot; &quot;ILLUMINA&quot; ... #&gt; $ RGPU : chr &quot;unit1&quot; &quot;unit1&quot; &quot;unit1&quot; &quot;unit1&quot; ... #&gt; $ filename_one : chr &quot;mpg_L16936-1_W1350_S1_R1_001.fastq.gz&quot; &quot;mpg_L16926-1_W1398_S2_R1_001.fastq.gz&quot; &quot;mpg_L16927-1_W1429_S3_R1_001.fastq.gz&quot; &quot;mpg_L16928-1_W1502_S4_R1_001.fastq.gz&quot; ... #&gt; $ filename_two : chr &quot;mpg_L16936-1_W1350_S1_R2_001.fastq.gz&quot; &quot;mpg_L16926-1_W1398_S2_R2_001.fastq.gz&quot; &quot;mpg_L16927-1_W1429_S3_R2_001.fastq.gz&quot; &quot;mpg_L16928-1_W1502_S4_R2_001.fastq.gz&quot; ... #&gt; $ reads_pre_trim_one : int 3844063 3360132 3034920 6695288 6040662 2842383 3879834 6087445 5686616 4107154 ... #&gt; $ reads_pre_trim_two : int 3844063 3360132 3034920 6695288 6040662 2842383 3879834 6087445 5686616 4107154 ... #&gt; $ reads_pre_trim_total : int 7688126 6720264 6069840 13390576 12081324 5684766 7759668 12174890 11373232 8214308 ... #&gt; $ reads_post_trim_one : int 3334957 3057420 2775271 6144973 5496263 2618095 3544978 5592586 5206646 3740830 ... #&gt; $ reads_post_trim_two : int 3317567 2622060 2444309 5472149 4763684 2298940 2933104 4916336 4551423 3252219 ... #&gt; $ reads_post_trim_total : int 6652524 5679480 5219580 11617122 10259947 4917035 6478082 10508922 9758069 6993049 ... #&gt; $ reads_trimmed_lost_one : int 509106 302712 259649 550315 544399 224288 334856 494859 479970 366324 ... #&gt; $ reads_trimmed_lost_two : int 526496 738072 590611 1223139 1276978 543443 946730 1171109 1135193 854935 ... #&gt; $ reads_trimmed_lost_total : int 1035602 1040784 850260 1773454 1821377 767731 1281586 1665968 1615163 1221259 ... #&gt; $ reads_trimmed_lost_total_percent : num 0.135 0.155 0.14 0.132 0.151 ... #&gt; $ reads_mapped : int 6448222 5897151 5344556 11948516 10542799 5052562 6862719 10880329 10069374 7213292 ... #&gt; $ reads_mapped_and_paired : int 6124942 4910684 4546908 10259622 8836944 4295176 5524338 9244878 8510126 6063336 ... #&gt; $ reads_unmapped : int 158628 176787 170192 251546 386867 143020 186719 234815 276382 223486 ... #&gt; $ reads_mapped_percent : num 0.975 0.97 0.968 0.979 0.963 ... #&gt; $ average_coverage : num 1.6 1.63 1.58 2.16 2.07 ... #&gt; $ average_coverarge_stdev : num 2.67 2.8 2.62 2.98 3.64 ... #&gt; $ unpaired_reads_examined_for_deduplication: int 323280 986467 797648 1688894 1705855 757386 1338381 1635451 1559248 1149956 ... #&gt; $ paired_reads_examined_for_deduplication : int 3094003 2475793 2291351 5174753 4449902 2167892 2782428 4657453 4288831 3054109 ... #&gt; $ unpaired_read_duplicated : int 66109 106320 78976 195164 185282 87774 136509 172933 169988 118239 ... #&gt; $ paired_read_duplicates : int 221442 119369 103005 260460 197926 115543 120104 206962 194659 133521 ... #&gt; $ percent_duplication : num 0.0782 0.0581 0.053 0.0595 0.0548 ... #&gt; $ sequenced_library_complexity : int 6090385 5720981 5222642 11474365 10330774 4870312 6664743 10519461 9774928 7042018 ... #&gt; $ estimated_library_complexity : int 23660823 29649178 29602264 59328308 57146455 23492191 37280729 60581428 54839066 40354282 ... #&gt; $ percent_library_sequenced : num 0.257 0.193 0.176 0.193 0.181 ... #&gt; $ original_reseq : chr &quot;reseq&quot; &quot;original&quot; &quot;original&quot; &quot;original&quot; ... #&gt; $ ID : chr &quot;W1350&quot; &quot;W1398&quot; &quot;W1429&quot; &quot;W1502&quot; ... save data overview save(data_overview, file = &quot;data_overview.RData&quot;) Calculate total and mean number of raw reads !!paired-end sequencing, so need to account for that total_raw_reads &lt;- sum(data_overview$reads_pre_trim_total) total_raw_reads #&gt; [1] 1393934732 mean_raw_reads &lt;- mean(data_overview$reads_pre_trim_total) mean_raw_reads #&gt; [1] 11713737 sd_raw_reads &lt;- sd(data_overview$reads_pre_trim_total) sd_raw_reads #&gt; [1] 5979400 Calculate total and mean number of quality filtered reads total_filtered_reads &lt;- sum(data_overview$reads_post_trim_total) total_filtered_reads #&gt; [1] 1218247416 percent_filtered_reads &lt;- total_filtered_reads/total_raw_reads percent_filtered_reads #&gt; [1] 0.873963 mean_filtered_reads &lt;- mean(data_overview$reads_post_trim_total) mean_filtered_reads #&gt; [1] 10237373 percent_mean_filtered_reads &lt;- mean_filtered_reads/mean_raw_reads percent_mean_filtered_reads #&gt; [1] 0.873963 sd_filtered_reads &lt;- sd(data_overview$reads_post_trim_total) sd_filtered_reads #&gt; [1] 5426886 median_Trimmomatic_dropped &lt;- median(data_overview$reads_trimmed_lost_total, na.rm = TRUE) median_Trimmomatic_dropped #&gt; [1] 1310301 IQR_Trimmomatic_dropped &lt;- IQR(data_overview$reads_trimmed_lost_total, na.rm = TRUE) IQR_Trimmomatic_dropped #&gt; [1] 749127 range_Trimmomatic_dropped &lt;- range(data_overview$reads_trimmed_lost_total, na.rm = TRUE) range_Trimmomatic_dropped #&gt; [1] 323232 4158669 Calculate mapped reads median_mapped_reads &lt;- median(data_overview$reads_mapped) median_mapped_reads #&gt; [1] 9498515 IQR_mapped_reads &lt;- IQR(data_overview$reads_mapped) IQR_mapped_reads #&gt; [1] 6902176 range_mapped_reads &lt;- range(data_overview$reads_mapped) range_mapped_reads #&gt; [1] 1843218 32346499 Calculate duplicates median_duplicates &lt;- median(data_overview$percent_duplication) median_duplicates #&gt; [1] 0.056526 range_duplicates &lt;- range(data_overview$percent_duplication) range_duplicates #&gt; [1] 0.039762 0.100763 Calculate final coverage median_final_coverage &lt;- median(data_overview$average_coverage) median_final_coverage #&gt; [1] 1.91596 IQR_final_coverage &lt;- IQR(data_overview$average_coverage) IQR_final_coverage #&gt; [1] 0.601805 range_final_coverage &lt;- range(data_overview$average_coverage) range_final_coverage #&gt; [1] 1.33748 4.31431 For the sequencing success, we compare the reads that passed Quality control (FastCQ and Trimmotaic) depending on original run (RGID = 1) and resequencing (RGID = 2). theme_set(theme_bw()) #set theme to black and white #compare reads (y-axis) between original vs. resequenced (x-axis, sorted to have original first) and color according to library prep (shotgun vs. capture) ggplot(data_overview, aes(x = factor(RGID, level = c(&quot;1&quot;, &quot;2&quot;)), y = reads_post_trim_total, color = original_reseq, shape = original_reseq)) + scale_color_viridis_d(end = 0.5) + geom_point(size = 2, alpha = 0.6, aes(group = ID), position = position_dodge(0.5)) + #make points, transparent, and group samples geom_boxplot(alpha = 0.4, outlier.shape = NA) + #add boxplots but do not show them in legend #geom_violin(alpha = 0.5) + #or add violin plots geom_line(aes(group = ID), color = &quot;grey&quot;, position = position_dodge(0.5), show.legend = FALSE) + #add line to connect samples present in both sequencing runs #stat_summary(fun = median, geom = &quot;point&quot;, size = 5, alpha = 0.3, position = position_dodge(0.5)) + labs(x = &quot;sequencing run&quot;, y = &quot;reads after quality filtering&quot;) + #adjust axis labels theme(legend.title = element_blank()) + #remove legend title theme(panel.grid.major.x = element_blank()) #remove x-axis grid lines Maybe more informative about the success of the approaches is to compare % reads that mapped. theme_set(theme_bw()) #set theme to black and white #compare mapped reads (y-axis) between sequencing (x-axis, sorted to have original first) and color according to sequencing run ggplot(data_overview, aes(x = factor(RGID, level = c(&quot;1&quot;, &quot;2&quot;)), y = reads_mapped_and_paired, color = original_reseq, shape = original_reseq)) + scale_color_viridis_d(end = 0.5) + geom_point(size = 2, alpha = 0.6, aes(group = ID), position = position_dodge(0.5)) + #make points, transparent, and group samples geom_boxplot(alpha = 0.4, outlier.shape = NA) + #add boxplots but do not show them in legend #geom_violin(alpha = 0.5) + #or add violin plots geom_line(aes(group = ID), color = &quot;grey&quot;, position = position_dodge(0.5), show.legend = FALSE) + #add line to connect samples present in both sequencing approaches #stat_summary(fun = median, geom = &quot;point&quot;, size = 5, alpha = 0.3, position = position_dodge(0.5)) + labs(x = &quot;sequencing run&quot;, y = &quot;mapped reads&quot;) + #adjust axis labels theme(legend.title = element_blank()) + #remove legend title theme(panel.grid.major.x = element_blank()) #remove x-axis grid lines Finally, lets have a look at the coverage theme_set(theme_bw()) #set theme to black and white #relate number of reads (y-axis) to final coverage (x-axis), color according to sequencing run (original vs. resequenced) and sample type, shape according to original run or resequencing ggplot(data_overview, aes(x = average_coverage, y = reads_post_trim_total, color = original_reseq, shape = original_reseq)) + scale_color_viridis_d(end = 0.5) + geom_line(aes(group = ID), color = &quot;lightgrey&quot;, show.legend = FALSE) + #connect same samples geom_point(alpha = 0.5, aes(size = reads_mapped_and_paired, group = ID)) + #add points with slight transparency geom_vline(xintercept = 1, linetype = &quot;dashed&quot;) + #include vertical line to show coverage cutoff #scale_y_log10(breaks = scales::trans_breaks(&quot;log10&quot;, function(x) 10^x), labels = scales::trans_format(&quot;log10&quot;, scales::math_format(10^.x))) + #make y-axis logarithmic #scale_x_log10() + #make x-axis logarithmic #annotation_logticks() + labs(x = &quot;coverage&quot;, y = &quot;reads (after quality filtering)&quot;, size = &quot;% reads mapped&quot;, color =&quot;&quot;, shape = &quot;&quot;) C-Curve theme_set(theme_bw()) #set theme to black and white #relate number of distinct reads (y-axis) to total reads (x-axis), color and shape according to original run or resequencing ggplot(data_overview, aes(x = unpaired_reads_examined_for_deduplication, y = sequenced_library_complexity, color = original_reseq, shape = original_reseq)) + geom_line(aes(group = ID), color = &quot;lightgrey&quot;, show.legend = FALSE) + #connect same samples geom_point(alpha = 0.5, aes(size = average_coverage, group = ID)) + #add points with slight transparency theme(panel.grid.minor.x = element_blank(), panel.grid.minor.y = element_blank()) + #remove x/y-axis grid lines labs(x = &quot;total unpaired reads&quot;, y = &quot;sequenced library complexity&quot;, size = &quot;coverage&quot;, color =&quot;&quot;, shape = &quot;&quot;) + #adjust axis and legend labels scale_color_viridis_d(end = 0.5) comparison to total surviving reads from Trimmomatic to distinct mapped reads theme_set(theme_bw()) #set theme to black and white #relate number of distinct reads (y-axis) to total surviving reads (x-axis), color and sample type, shape according to original run or resequencing ggplot(data_overview, aes(x = reads_post_trim_total, y = sequenced_library_complexity, color = original_reseq, shape = original_reseq)) + scale_color_viridis_d(end = 0.5) + geom_point(alpha = 0.5, aes(size = average_coverage, group = ID)) + #add points with slight transparency theme(panel.grid.minor.x = element_blank(), panel.grid.minor.y = element_blank()) + #remove x/y-axis grid lines labs(x = &quot;total surviving reads (Trimmomatic)&quot;, y = &quot;sequenced library complexity&quot;, size = &quot;coverage&quot;, color =&quot;&quot;, shape = &quot;&quot;) #adjust axis and legend labels plot coverage and st.dv. theme_set(theme_bw()) #set theme to black and white #plot coverage (y-axis) including st.dev for every sample (x-axis), color according to original run or resequencing ggplot(filter(data_overview, original_reseq == &quot;original&quot;), aes(x = reorder(ID, average_coverage), y = average_coverage, color = original_reseq, shape = original_reseq)) + scale_color_viridis_d(end = 0.5) + geom_point(aes(y=average_coverage), alpha = 0.8) + geom_point(data = filter(data_overview, original_reseq == &quot;reseq&quot;), aes(y=average_coverage), alpha = 0.8) + geom_errorbar(data = filter(data_overview, original_reseq == &quot;reseq&quot;), aes(ymin = average_coverage - average_coverarge_stdev, ymax = average_coverage + average_coverarge_stdev), alpha = 0.8) + geom_errorbar(aes(ymin = average_coverage - average_coverarge_stdev, ymax = average_coverage + average_coverarge_stdev), alpha = 0.8) + geom_hline(yintercept = 1, linetype = &quot;dashed&quot;) + #include horizontal line to show coverage cutoff at 1X geom_hline(yintercept = median_final_coverage, linetype = &quot;dotted&quot;) + coord_cartesian(ylim = c(0, 10)) + #adjust y axis scale_y_continuous(breaks = c(0, 2, 4, 6, 8, 10)) + labs(x = &quot;sample&quot;, y = &quot;coverage (mean+-sd)&quot;, color =&quot;&quot;, shape = &quot;&quot;) + #adjust axis and legend labels theme(axis.text.x = element_text(angle = 50, vjust = 1, hjust = 1, size = 8)) + scale_x_discrete(guide = guide_axis(n.dodge=2)) #avoid overlap of x-axis labels 4.3.2 Relatedness data 4.3.2.1 ngsRelate This is an assessment of the ngsRelate results produced by the Nextflow pipleine created by Ben Hume/SeqAna. The data is saved in the folder pipeline in ngsrelate as relatedness.isec.0002.exMito.thinned.ngsrelate.w.sample.names.results. We now use the results excluding replicated samples and the Z chromosome, which are stored in pipeline/no_repeats_no_Z_relatedness_results/nextflow_output/ngsrelate. ngsRelate_results &lt;- read.delim(&quot;vignettes/data/pipeline/no_repeats_no_Z_relatedness_results/nextflow_output/ngsrelate/relatedness.isec.0002.exMito.thinned.ngsrelate.results&quot;, header = TRUE, as.is = TRUE) str(ngsRelate_results) #&gt; &#39;data.frame&#39;: 4560 obs. of 35 variables: #&gt; $ a : int 0 0 0 0 0 0 0 0 0 0 ... #&gt; $ b : int 1 2 3 4 5 6 7 8 9 10 ... #&gt; $ ida : chr &quot;RGID1_S83&quot; &quot;RGID1_S83&quot; &quot;RGID1_S83&quot; &quot;RGID1_S83&quot; ... #&gt; $ idb : chr &quot;RGID1_S82&quot; &quot;RGID1_S29&quot; &quot;RGID1_S2&quot; &quot;RGID2_S13&quot; ... #&gt; $ nSites : int 614924 527474 430254 612597 599536 515211 460041 591284 452116 488952 ... #&gt; $ J9 : num 0.823 0.636 0.427 0.863 0.864 ... #&gt; $ J8 : num 0.0 1.4e-05 1.0e-06 0.0 1.0e-06 0.0 0.0 1.0e-06 3.0e-06 0.0 ... #&gt; $ J7 : num 0.0895 0.0603 0.1184 0.0536 0.0468 ... #&gt; $ J6 : num 0 0.208 0.412 0 0 ... #&gt; $ J5 : num 4e-06 0e+00 1e-05 0e+00 0e+00 0e+00 0e+00 0e+00 0e+00 0e+00 ... #&gt; $ J4 : num 0.05385 0 0 0.030893 0.000062 ... #&gt; $ J3 : num 0e+00 2e-06 0e+00 0e+00 0e+00 0e+00 0e+00 2e-06 0e+00 0e+00 ... #&gt; $ J2 : num 0.0336 0.0959 0.0429 0.0528 0.0888 ... #&gt; $ J1 : num 1.0e-06 0.0 4.3e-05 1.0e-06 0.0 0.0 0.0 1.0e-06 0.0 0.0 ... #&gt; $ rab : num 0.0895 0.0604 0.1185 0.0536 0.0468 ... #&gt; $ Fa : num 0.0875 0.096 0.0429 0.0837 0.0889 ... #&gt; $ Fb : num 0.0336 0.3037 0.4548 0.0528 0.0888 ... #&gt; $ theta : num 0.0448 0.0302 0.0593 0.0268 0.0234 ... #&gt; $ inbred_relatedness_1_2: num 1.0e-06 1.0e-06 4.3e-05 1.0e-06 0.0 0.0 0.0 2.0e-06 0.0 0.0 ... #&gt; $ inbred_relatedness_2_1: num 3.0e-06 0.0 4.8e-05 1.0e-06 0.0 0.0 0.0 1.0e-06 0.0 0.0 ... #&gt; $ fraternity : num 0.123 0.156 0.161 0.106 0.136 ... #&gt; $ identity : num 1.0e-06 0.0 4.3e-05 1.0e-06 0.0 0.0 0.0 1.0e-06 0.0 0.0 ... #&gt; $ zygosity : num 0.123 0.156 0.161 0.106 0.136 ... #&gt; $ X2of3_IDB : num 0.15 0.26 0.367 0.122 0.136 ... #&gt; $ F_diff_a_b : num 0.026925 -0.103875 -0.205954 0.015446 0.000031 ... #&gt; $ loglh : num -969430 -844356 -677157 -969593 -955122 ... #&gt; $ nIter : int 54 62 78 62 62 54 38 46 42 58 ... #&gt; $ bestoptimll : int -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 ... #&gt; $ coverage : num 0.926 0.794 0.648 0.922 0.903 ... #&gt; $ X2dsfs : chr &quot;3.136819e-01,1.279287e-01,4.005387e-02,1.011532e-01,1.812662e-01,4.215345e-02,4.391939e-02,6.001794e-02,8.982536e-02&quot; &quot;3.378250e-01,7.470870e-02,6.303665e-02,1.394846e-01,1.300943e-01,6.827356e-02,5.710377e-02,3.065345e-02,9.882001e-02&quot; &quot;3.561888e-01,5.169090e-02,6.016002e-02,1.556270e-01,1.122636e-01,8.533396e-02,5.128981e-02,1.941323e-02,1.080326e-01&quot; &quot;3.059626e-01,1.306980e-01,4.481334e-02,1.026846e-01,1.786007e-01,4.361379e-02,4.825899e-02,5.768462e-02,8.768329e-02&quot; ... #&gt; $ R0 : num 0.463 0.923 0.993 0.521 0.581 ... #&gt; $ R1 : num 0.437 0.3 0.265 0.418 0.401 ... #&gt; $ KING : num 0.0192 -0.1922 -0.2062 -0.0109 -0.0414 ... #&gt; $ X2dsfs_loglike : num -1205546 -1035930 -823225 -1210883 -1188795 ... #&gt; $ X2dsfsf_niter : int 10 10 10 9 10 10 10 10 10 10 ... Relatedness was estimated on an average of 4.675586810^{5} sites and a mean coverage of 0.7040709. On average, relatedness is 0.0580915 with a range of 2.3810^{-4}, 0.262088. We join together the relatedness estimates with the sample information, to know the identity of the dyads #rename &quot;ida&quot; and &quot;idb&quot; to &quot;RGSM_a&quot; and &quot;RGSM-b&quot; ngsRelate_results &lt;- rename(ngsRelate_results, &quot;RGSM_a&quot; = &quot;ida&quot;) ngsRelate_results &lt;- rename(ngsRelate_results, &quot;RGSM_b&quot; = &quot;idb&quot;) #create a new column that includes RGSM_dyad ngsRelate_results$RGSM_dyad &lt;- if_else(ngsRelate_results$RGSM_a &lt; ngsRelate_results$RGSM_b, paste(ngsRelate_results$RGSM_a, ngsRelate_results$RGSM_b, sep = &quot;-&quot;), paste(ngsRelate_results$RGSM_b, ngsRelate_results$RGSM_a, sep = &quot;-&quot;)) #first include ID of individual a ngsRelate_results_ID &lt;- left_join(ngsRelate_results, seqlib_overview[6:7], by = c(&quot;RGSM_a&quot; = &quot;RGSM&quot;)) #rename &quot;ID&quot; to &quot;ID_a&quot; ngsRelate_results_ID &lt;- rename(ngsRelate_results_ID, &quot;ID_a&quot; = &quot;ID&quot;) #now include ID of individual b ngsRelate_results_ID &lt;- left_join(ngsRelate_results_ID, seqlib_overview[6:7], by = c(&quot;RGSM_b&quot; = &quot;RGSM&quot;)) #rename &quot;ID&quot; to &quot;ID_b&quot; ngsRelate_results_ID &lt;- rename(ngsRelate_results_ID, &quot;ID_b&quot; = &quot;ID&quot;) #create a new column that includes the dyad ngsRelate_results_ID$dyad &lt;- if_else(ngsRelate_results_ID$ID_a &lt; ngsRelate_results_ID$ID_b, paste(ngsRelate_results_ID$ID_a, ngsRelate_results_ID$ID_b, sep = &quot;-&quot;), paste(ngsRelate_results_ID$ID_b, ngsRelate_results_ID$ID_a, sep = &quot;-&quot;)) #remove duplicates ##maybe not necessary anymore ngsRelate_results_ID &lt;- distinct(ngsRelate_results_ID) We also include the group information #first include group of individual a ngsRelate_results_sample_info &lt;- left_join(ngsRelate_results_ID, sample_info, by = c(&quot;ID_a&quot; = &quot;ID&quot;)) #rename &quot;Group_ID&quot; to &quot;a_Group&quot; and &quot;sex&quot; to &quot;a_sex&quot; ngsRelate_results_sample_info &lt;- rename(ngsRelate_results_sample_info, &quot;a_Group&quot; = &quot;Group_ID&quot;) ngsRelate_results_sample_info &lt;- rename(ngsRelate_results_sample_info, &quot;a_sex&quot; = &quot;sex&quot;) #then include group of individual b ngsRelate_results_sample_info &lt;- left_join(ngsRelate_results_sample_info, sample_info, by = c(&quot;ID_b&quot; = &quot;ID&quot;)) #rename &quot;Group_ID&quot; to &quot;b_Group&quot; and &quot;sex&quot; to &quot;b_sex&quot; ngsRelate_results_sample_info &lt;- rename(ngsRelate_results_sample_info, &quot;b_Group&quot; = &quot;Group_ID&quot;) ngsRelate_results_sample_info &lt;- rename(ngsRelate_results_sample_info, &quot;b_sex&quot; = &quot;sex&quot;) #which group IDs are there? sort(unique(ngsRelate_results_sample_info$a_Group)) #&gt; [1] &quot;5509&quot; &quot;5512&quot; &quot;5931-5938&quot; &quot;dump&quot; &quot;mpala&quot; #&gt; [6] &quot;mpala_chicks&quot; &quot;ROOP&quot; &quot;RRWB&quot; &quot;wing_tags&quot; &quot;wt025&quot; sort(unique(ngsRelate_results_sample_info$b_Group)) #&gt; [1] &quot;5509&quot; &quot;5512&quot; &quot;5931-5938&quot; &quot;dump&quot; &quot;mpala&quot; #&gt; [6] &quot;mpala_chicks&quot; &quot;ROOP&quot; &quot;RRWB&quot; &quot;wing_tags&quot; &quot;wt025&quot; #create new column that specifies if individuals are from same or different groups ngsRelate_results_sample_info &lt;- ngsRelate_results_sample_info %&gt;% mutate(dyad_group = case_when(ID_a == ID_b ~ &quot;identical&quot;, a_Group == b_Group ~ &quot;intragroup&quot;, a_Group != b_Group ~ &quot;intergroup&quot;)) unique(ngsRelate_results_sample_info$dyad_group) #&gt; [1] &quot;intragroup&quot; &quot;intergroup&quot; #create new column that specifies if individuals have same or different sex ngsRelate_results_sample_info &lt;- ngsRelate_results_sample_info %&gt;% mutate(dyad_sex = case_when(ID_a == ID_b ~ &quot;identical&quot;, a_sex == b_sex ~ &quot;same sex&quot;, a_sex != b_sex ~ &quot;male-female&quot;)) #recode dyads for individuals with undetermined sex to NA ngsRelate_results_sample_info$dyad_sex[ngsRelate_results_sample_info$a_sex == &quot;u&quot;] &lt;- NA ngsRelate_results_sample_info$dyad_sex[ngsRelate_results_sample_info$b_sex == &quot;u&quot;] &lt;- NA #recode same sex dyads to male or female ngsRelate_results_sample_info$dyad_sex[ngsRelate_results_sample_info$dyad_sex == &quot;same sex&quot; &amp; ngsRelate_results_sample_info$a_sex == &quot;f&quot;] &lt;- &quot;female&quot; ngsRelate_results_sample_info$dyad_sex[ngsRelate_results_sample_info$dyad_sex == &quot;same sex&quot; &amp; ngsRelate_results_sample_info$a_sex == &quot;m&quot;] &lt;- &quot;male&quot; unique(ngsRelate_results_sample_info$dyad_sex) #&gt; [1] &quot;male-female&quot; NA &quot;female&quot; &quot;male&quot; Lets have a closer look at the samples that were sequenced twice #find samples that were sequenced twice duplicates &lt;- filter(ngsRelate_results_sample_info, ID_a == ID_b) #average relatedness of these duplicted inidividuals mean(duplicates$rab) #&gt; [1] NaN #range range(duplicates$rab) #&gt; Warning in min(x): kein nicht-fehlendes Argument für min; gebe Inf zurück #&gt; Warning in max(x): kein nicht-fehlendes Argument für max; gebe -Inf zurück #&gt; [1] Inf -Inf Create subset with at least 250k SNPs ngsRelate_results_sample_info_250k &lt;- filter(ngsRelate_results_sample_info, nSites &gt;= 250000) unique(ngsRelate_results_sample_info_250k$dyad_group) #&gt; [1] &quot;intragroup&quot; &quot;intergroup&quot; To get an overview of the distribution of relatedness coefficients, we plot pairwise relatedness for all dyads theme_set(theme_classic()) #plot relatedness rab (y-axis) for every dyad (x-axis), ordered from low to high relatedness and colored according to inter- or intragroup dyad ggplot(ngsRelate_results_sample_info_250k, aes(x = reorder(dyad, rab), y = rab, color = dyad_sex, shape = dyad_group)) + geom_point(alpha = 0.2, aes(y = rab)) + #plot relatedness estimates as points geom_hline(yintercept = c(0.125, 0.25, 0.5), linetype = &quot;dashed&quot;) + #include horizontal line to show traditional kinship categories labs( x = &quot;Dyad&quot;, y = &quot;Relatedness (ngsRelate)&quot;) + ggtitle(&quot;distribution of relatedness (ngsrelate) 250k&quot;) check correlation between number of SNPs and sex theme_set(theme_classic()) #plot nSites (y-axis) and for the different categories of sex of dyad (x-axis) colored according to coverage ggplot(ngsRelate_results_sample_info, aes(x = dyad_sex, y = nSites, color = coverage, shape = dyad_group)) + geom_point(alpha = 0.2) + geom_boxplot() ggtitle(&quot;nsites vs sex&quot;) #&gt; $title #&gt; [1] &quot;nsites vs sex&quot; #&gt; #&gt; attr(,&quot;class&quot;) #&gt; [1] &quot;labels&quot; Compare relatedness estimates according to group and sex theme_set(theme_classic()) #plot relatedness rab (y-axis) for the different categories of sex of dyad (x-axis) colored according to group membership ggplot(ngsRelate_results_sample_info_250k, aes(x = dyad_sex, y = rab, color = dyad_group, shape = dyad_group)) + geom_point(alpha = 0.2, position = position_dodge(0.5)) + geom_boxplot(alpha = 0.4, outlier.shape = NA) ggtitle(&quot;relatedness (ngsrelate) 250k&quot;) #&gt; $title #&gt; [1] &quot;relatedness (ngsrelate) 250k&quot; #&gt; #&gt; attr(,&quot;class&quot;) #&gt; [1] &quot;labels&quot; 4.3.2.2 lcmlkin We now use the results excluding replicated samples, which are stored in pipeline/no_repeats_relatedness_results/nf_results/lcmlkin lcmlkin_results &lt;- read.delim(&quot;vignettes/data/pipeline/no_repeats_relatedness_results/nf_results/lcmlkin/relatedness.isec.0002.exMito.thinned.lcmlkin.results&quot;, header = TRUE, as.is = TRUE) str(lcmlkin_results) #&gt; &#39;data.frame&#39;: 4560 obs. of 7 variables: #&gt; $ Ind1 : chr &quot;RGID1_S83&quot; &quot;RGID1_S83&quot; &quot;RGID1_S83&quot; &quot;RGID1_S83&quot; ... #&gt; $ Ind2 : chr &quot;RGID1_S49&quot; &quot;RGID2_S13&quot; &quot;RGID1_S89&quot; &quot;RGID2_S11&quot; ... #&gt; $ k0_hat: num 0.911 0.878 0.835 0.815 0.863 0.904 0.814 0.816 0.877 0.903 ... #&gt; $ k1_hat: num 0 0.002 0.004 0.003 0.002 0.003 0.005 0.003 0.002 0.003 ... #&gt; $ k2_hat: num 0.089 0.12 0.162 0.182 0.134 0.093 0.182 0.18 0.121 0.094 ... #&gt; $ pi_HAT: num 0.089 0.121 0.164 0.183 0.136 0.094 0.184 0.182 0.122 0.096 ... #&gt; $ nbSNP : int 617110 729018 615902 622500 713042 579737 518643 623265 704472 603659 ... We join together the relatedness estimates with the sample information, to know the identity of the dyads #rename &quot;ida&quot; and &quot;idb&quot; to &quot;RGSM_a&quot; and &quot;RGSM-b&quot; lcmlkin_results &lt;- rename(lcmlkin_results, &quot;RGSM_a&quot; = &quot;Ind1&quot;) lcmlkin_results &lt;- rename(lcmlkin_results, &quot;RGSM_b&quot; = &quot;Ind2&quot;) #create a new column that includes RGSM_dyad lcmlkin_results$RGSM_dyad &lt;- if_else(lcmlkin_results$RGSM_a &lt; lcmlkin_results$RGSM_b, paste(lcmlkin_results$RGSM_a, lcmlkin_results$RGSM_b, sep = &quot;-&quot;), paste(lcmlkin_results$RGSM_b, lcmlkin_results$RGSM_a, sep = &quot;-&quot;)) #first include ID of individual a lcmlkin_results_ID &lt;- left_join(lcmlkin_results, seqlib_overview[6:7], by = c(&quot;RGSM_a&quot; = &quot;RGSM&quot;)) #rename &quot;ID&quot; to &quot;ID_a&quot; lcmlkin_results_ID &lt;- rename(lcmlkin_results_ID, &quot;ID_a&quot; = &quot;ID&quot;) #now include ID of individual b lcmlkin_results_ID &lt;- left_join(lcmlkin_results_ID, seqlib_overview[6:7], by = c(&quot;RGSM_b&quot; = &quot;RGSM&quot;)) #rename &quot;ID&quot; to &quot;ID_b&quot; lcmlkin_results_ID &lt;- rename(lcmlkin_results_ID, &quot;ID_b&quot; = &quot;ID&quot;) #create a new column that includes the dyad lcmlkin_results_ID$dyad &lt;- if_else(lcmlkin_results_ID$ID_a &lt; lcmlkin_results_ID$ID_b, paste(lcmlkin_results_ID$ID_a, lcmlkin_results_ID$ID_b, sep = &quot;-&quot;), paste(lcmlkin_results_ID$ID_b, lcmlkin_results_ID$ID_a, sep = &quot;-&quot;)) #remove duplicates ##maybe not necessary anymore lcmlkin_results_ID &lt;- distinct(lcmlkin_results_ID) We also include the group information #first include group of individual a lcmlkin_results_sample_info &lt;- left_join(lcmlkin_results_ID, sample_info, by = c(&quot;ID_a&quot; = &quot;ID&quot;)) #rename &quot;Group_ID&quot; to &quot;a_Group&quot; lcmlkin_results_sample_info &lt;- rename(lcmlkin_results_sample_info, &quot;a_Group&quot; = &quot;Group_ID&quot;) lcmlkin_results_sample_info &lt;- rename(lcmlkin_results_sample_info, &quot;a_sex&quot; = &quot;sex&quot;) #then include group of individual b lcmlkin_results_sample_info &lt;- left_join(lcmlkin_results_sample_info, sample_info, by = c(&quot;ID_b&quot; = &quot;ID&quot;)) lcmlkin_results_sample_info &lt;- rename(lcmlkin_results_sample_info, &quot;b_sex&quot; = &quot;sex&quot;) #rename &quot;Group_ID&quot; to &quot;b_Group&quot; lcmlkin_results_sample_info &lt;- rename(lcmlkin_results_sample_info, &quot;b_Group&quot; = &quot;Group_ID&quot;) #create new column that specifies if individuals are from same or different groups lcmlkin_results_sample_info &lt;- lcmlkin_results_sample_info %&gt;% mutate(dyad_group = if_else(a_Group == b_Group, &quot;intra&quot;, &quot;inter&quot;)) str(lcmlkin_results_sample_info) #&gt; &#39;data.frame&#39;: 4560 obs. of 16 variables: #&gt; $ RGSM_a : chr &quot;RGID1_S83&quot; &quot;RGID1_S83&quot; &quot;RGID1_S83&quot; &quot;RGID1_S83&quot; ... #&gt; $ RGSM_b : chr &quot;RGID1_S49&quot; &quot;RGID2_S13&quot; &quot;RGID1_S89&quot; &quot;RGID2_S11&quot; ... #&gt; $ k0_hat : num 0.911 0.878 0.835 0.815 0.863 0.904 0.814 0.816 0.877 0.903 ... #&gt; $ k1_hat : num 0 0.002 0.004 0.003 0.002 0.003 0.005 0.003 0.002 0.003 ... #&gt; $ k2_hat : num 0.089 0.12 0.162 0.182 0.134 0.093 0.182 0.18 0.121 0.094 ... #&gt; $ pi_HAT : num 0.089 0.121 0.164 0.183 0.136 0.094 0.184 0.182 0.122 0.096 ... #&gt; $ nbSNP : int 617110 729018 615902 622500 713042 579737 518643 623265 704472 603659 ... #&gt; $ RGSM_dyad : chr &quot;RGID1_S49-RGID1_S83&quot; &quot;RGID1_S83-RGID2_S13&quot; &quot;RGID1_S83-RGID1_S89&quot; &quot;RGID1_S83-RGID2_S11&quot; ... #&gt; $ ID_a : chr &quot;WT00386&quot; &quot;WT00386&quot; &quot;WT00386&quot; &quot;WT00386&quot; ... #&gt; $ ID_b : chr &quot;A1307&quot; &quot;A1312&quot; &quot;W1671&quot; &quot;W1673&quot; ... #&gt; $ dyad : chr &quot;A1307-WT00386&quot; &quot;A1312-WT00386&quot; &quot;W1671-WT00386&quot; &quot;W1673-WT00386&quot; ... #&gt; $ a_Group : chr &quot;mpala_chicks&quot; &quot;mpala_chicks&quot; &quot;mpala_chicks&quot; &quot;mpala_chicks&quot; ... #&gt; $ a_sex : chr &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; ... #&gt; $ b_Group : chr &quot;wing_tags&quot; &quot;wing_tags&quot; &quot;wt025&quot; &quot;wt025&quot; ... #&gt; $ b_sex : chr &quot;m&quot; &quot;m&quot; &quot;f&quot; &quot;f&quot; ... #&gt; $ dyad_group: chr &quot;inter&quot; &quot;inter&quot; &quot;inter&quot; &quot;inter&quot; ... #create new column that specifies if individuals have same or different sex lcmlkin_results_sample_info &lt;- lcmlkin_results_sample_info %&gt;% mutate(dyad_sex = case_when(ID_a == ID_b ~ &quot;identical&quot;, a_sex == b_sex ~ &quot;same sex&quot;, a_sex != b_sex ~ &quot;male-female&quot;)) #recode dyads for individuals with undetermined sex to NA lcmlkin_results_sample_info$dyad_sex[lcmlkin_results_sample_info$a_sex == &quot;u&quot;] &lt;- NA lcmlkin_results_sample_info$dyad_sex[lcmlkin_results_sample_info$b_sex == &quot;u&quot;] &lt;- NA #recode same sex dyads to male or female lcmlkin_results_sample_info$dyad_sex[lcmlkin_results_sample_info$dyad_sex == &quot;same sex&quot; &amp; lcmlkin_results_sample_info$a_sex == &quot;f&quot;] &lt;- &quot;female&quot; lcmlkin_results_sample_info$dyad_sex[lcmlkin_results_sample_info$dyad_sex == &quot;same sex&quot; &amp; lcmlkin_results_sample_info$a_sex == &quot;m&quot;] &lt;- &quot;male&quot; unique(lcmlkin_results_sample_info$dyad_sex) #&gt; [1] &quot;male-female&quot; &quot;female&quot; NA &quot;male&quot; Lets have a closer look at the samples that were sequenced twice #find samples that were sequenced twice duplicates_lcmlkin &lt;- filter(lcmlkin_results_sample_info, ID_a == ID_b) #average relatedness of these duplicted inidividuals mean(duplicates_lcmlkin$pi_HAT) #&gt; [1] NaN #range range(duplicates_lcmlkin$pi_HAT) #&gt; Warning in min(x): kein nicht-fehlendes Argument für min; gebe Inf zurück #&gt; Warning in max(x): kein nicht-fehlendes Argument für max; gebe -Inf zurück #&gt; [1] Inf -Inf Create subset with at least 300k SNPs lcmlkin_results_sample_info_300k &lt;- filter(lcmlkin_results_sample_info, nbSNP &gt;= 300000) theme_set(theme_classic()) #plot relatedness pi_HAT (y-axis) for every dyad (x-axis), ordered from low to high relatedness and colored according to inter- or intragroup dyad ggplot(lcmlkin_results_sample_info_300k, aes(x = reorder(dyad, pi_HAT), y = pi_HAT, color = dyad_sex, shape = dyad_group)) + geom_point(alpha = 0.1, aes(y = pi_HAT)) + #plot relatedness estimates as points geom_hline(yintercept = c(0.125, 0.25, 0.5), linetype = &quot;dashed&quot;) + #include horizontal line to show traditional kinship categories labs( x = &quot;Dyad&quot;, y = &quot;Relatedness (lcmlkin)&quot;) + ggtitle(&quot;distribution of relatedness (lcmlkin) 300k SNPs&quot;) theme_set(theme_classic()) #plot relatedness pi_HAT (y-axis) and corresponding k0 (x-axis) colored according to nbSNP ggplot(lcmlkin_results_sample_info, aes(x = k0_hat, y = pi_HAT, color = nbSNP, shape = dyad_group)) + geom_point(alpha = 0.2) + ggtitle(&quot;lcmlkin k0 vs phi&quot;) check correlation between number of SNPs and sex theme_set(theme_classic()) #plot nbSNPs (y-axis) and for the different categories of sex of dyad (x-axis) colored according to dyad_group ggplot(lcmlkin_results_sample_info, aes(x = dyad_sex, y = nbSNP, color = dyad_group, shape = dyad_group)) + geom_point(alpha = 0.2) + geom_boxplot() ggtitle(&quot;nbSNP vs sex of dyad&quot;) #&gt; $title #&gt; [1] &quot;nbSNP vs sex of dyad&quot; #&gt; #&gt; attr(,&quot;class&quot;) #&gt; [1] &quot;labels&quot; theme_set(theme_classic()) #plot relatedness pi_HAT (y-axis) for the different categories of sex of dyad (x-axis) colored according to group membership ggplot(lcmlkin_results_sample_info_300k, aes(x = dyad_group, y = pi_HAT, color = dyad_sex)) + geom_point(alpha = 0.2) + geom_boxplot() ggtitle(&quot;relatedness (lcmlkin) 300k&quot;) #&gt; $title #&gt; [1] &quot;relatedness (lcmlkin) 300k&quot; #&gt; #&gt; attr(,&quot;class&quot;) #&gt; [1] &quot;labels&quot; 4.3.2.3 READ This is an assessment of the READ results produced by the Nextflow pipleine created by Ben Hume/SeqAna. The data is saved in the folder pipeline in read as meansP0_AncientDNA_normalized. The preprocessed data (categorizes unrelated, first- and second-order related) is sotred as READ_results. READ_rawresults &lt;- read.delim(&quot;vignettes/data/pipeline/no_repeats_relatedness_results/nf_results/read/meansP0_AncientDNA_normalized&quot;, header = TRUE, sep = &quot; &quot;, as.is = TRUE) str(READ_rawresults) #&gt; &#39;data.frame&#39;: 4560 obs. of 5 variables: #&gt; $ PairIndividuals : chr &quot;RGID1_S10RGID1_S11&quot; &quot;RGID1_S10RGID1_S26&quot; &quot;RGID1_S10RGID1_S36&quot; &quot;RGID1_S10RGID1_S39&quot; ... #&gt; $ Normalized2AlleleDifference: num 0.954 0.968 0.931 0.972 0.985 ... #&gt; $ StandardError : num 0.00477 0.00498 0.00534 0.00472 0.00489 ... #&gt; $ NonNormalizedP0 : num 0.341 0.346 0.333 0.347 0.352 ... #&gt; $ NonNormalizedStandardError : num 0.0017 0.00178 0.00191 0.00169 0.00175 ... READ_kinresults &lt;- read.delim(&quot;vignettes/data/pipeline/no_repeats_relatedness_results/nf_results/read/READ_results&quot;, header = TRUE, sep = &quot;\\t&quot;, as.is = TRUE) str(READ_kinresults) #&gt; &#39;data.frame&#39;: 4560 obs. of 4 variables: #&gt; $ PairIndividuals: chr &quot;RGID1_S10RGID1_S11&quot; &quot;RGID1_S10RGID1_S26&quot; &quot;RGID1_S10RGID1_S36&quot; &quot;RGID1_S10RGID1_S39&quot; ... #&gt; $ Relationship : chr &quot;Unrelated&quot; &quot;Unrelated&quot; &quot;Unrelated&quot; &quot;Unrelated&quot; ... #&gt; $ Z_upper : num NA NA NA NA NA NA NA NA NA NA ... #&gt; $ Z_lower : num -9.91 -12.35 -4.68 -13.99 -16.15 ... Merge these two result files READ_results &lt;- left_join(READ_rawresults, READ_kinresults, by = &quot;PairIndividuals&quot;) str(READ_results) #&gt; &#39;data.frame&#39;: 4560 obs. of 8 variables: #&gt; $ PairIndividuals : chr &quot;RGID1_S10RGID1_S11&quot; &quot;RGID1_S10RGID1_S26&quot; &quot;RGID1_S10RGID1_S36&quot; &quot;RGID1_S10RGID1_S39&quot; ... #&gt; $ Normalized2AlleleDifference: num 0.954 0.968 0.931 0.972 0.985 ... #&gt; $ StandardError : num 0.00477 0.00498 0.00534 0.00472 0.00489 ... #&gt; $ NonNormalizedP0 : num 0.341 0.346 0.333 0.347 0.352 ... #&gt; $ NonNormalizedStandardError : num 0.0017 0.00178 0.00191 0.00169 0.00175 ... #&gt; $ Relationship : chr &quot;Unrelated&quot; &quot;Unrelated&quot; &quot;Unrelated&quot; &quot;Unrelated&quot; ... #&gt; $ Z_upper : num NA NA NA NA NA NA NA NA NA NA ... #&gt; $ Z_lower : num -9.91 -12.35 -4.68 -13.99 -16.15 ... Now we need to split the PairIndividuals into individual 1 and 2, identify these individuals and then create the dyads corresponding to the previous results. #Need to split PairIndividuals into 2 new columns READ_results$RGSM_a &lt;- gsub(&quot;(RGID[[:alnum:]]{1}_S[[:alnum:]]{1,2})(RGID[[:alnum:]]{1}_S[[:alnum:]]{1,2})&quot;, &quot;\\\\1&quot;, READ_results$PairIndividuals) READ_results$RGSM_b &lt;- gsub(&quot;(RGID[[:alnum:]]{1}_S[[:alnum:]]{1,2})(RGID[[:alnum:]]{1}_S[[:alnum:]]{1,2})&quot;, &quot;\\\\2&quot;, READ_results$PairIndividuals) #create a new column that includes RGSM_dyad READ_results$RGSM_dyad &lt;- if_else(READ_results$RGSM_a &lt; READ_results$RGSM_b, paste(READ_results$RGSM_a, READ_results$RGSM_b, sep = &quot;-&quot;), paste(READ_results$RGSM_b, READ_results$RGSM_a, sep = &quot;-&quot;)) str(READ_results) #&gt; &#39;data.frame&#39;: 4560 obs. of 11 variables: #&gt; $ PairIndividuals : chr &quot;RGID1_S10RGID1_S11&quot; &quot;RGID1_S10RGID1_S26&quot; &quot;RGID1_S10RGID1_S36&quot; &quot;RGID1_S10RGID1_S39&quot; ... #&gt; $ Normalized2AlleleDifference: num 0.954 0.968 0.931 0.972 0.985 ... #&gt; $ StandardError : num 0.00477 0.00498 0.00534 0.00472 0.00489 ... #&gt; $ NonNormalizedP0 : num 0.341 0.346 0.333 0.347 0.352 ... #&gt; $ NonNormalizedStandardError : num 0.0017 0.00178 0.00191 0.00169 0.00175 ... #&gt; $ Relationship : chr &quot;Unrelated&quot; &quot;Unrelated&quot; &quot;Unrelated&quot; &quot;Unrelated&quot; ... #&gt; $ Z_upper : num NA NA NA NA NA NA NA NA NA NA ... #&gt; $ Z_lower : num -9.91 -12.35 -4.68 -13.99 -16.15 ... #&gt; $ RGSM_a : chr &quot;RGID1_S10&quot; &quot;RGID1_S10&quot; &quot;RGID1_S10&quot; &quot;RGID1_S10&quot; ... #&gt; $ RGSM_b : chr &quot;RGID1_S11&quot; &quot;RGID1_S26&quot; &quot;RGID1_S36&quot; &quot;RGID1_S39&quot; ... #&gt; $ RGSM_dyad : chr &quot;RGID1_S10-RGID1_S11&quot; &quot;RGID1_S10-RGID1_S26&quot; &quot;RGID1_S10-RGID1_S36&quot; &quot;RGID1_S10-RGID1_S39&quot; ... We join together the relatedness estimates with the sample information, to know the identity of the dyads #first include ID of individual a READ_results_ID &lt;- left_join(READ_results, seqlib_overview[6:7], by = c(&quot;RGSM_a&quot; = &quot;RGSM&quot;)) #rename &quot;ID&quot; to &quot;ID_a&quot; READ_results_ID &lt;- rename(READ_results_ID, &quot;ID_a&quot; = &quot;ID&quot;) #now include ID of individual b READ_results_ID &lt;- left_join(READ_results_ID, seqlib_overview[6:7], by = c(&quot;RGSM_b&quot; = &quot;RGSM&quot;)) #rename &quot;ID&quot; to &quot;ID_b&quot; READ_results_ID &lt;- rename(READ_results_ID, &quot;ID_b&quot; = &quot;ID&quot;) #create a new column that includes the dyad READ_results_ID$dyad &lt;- if_else(READ_results_ID$ID_a &lt; READ_results_ID$ID_b, paste(READ_results_ID$ID_a, READ_results_ID$ID_b, sep = &quot;-&quot;), paste(READ_results_ID$ID_b, READ_results_ID$ID_a, sep = &quot;-&quot;)) #remove duplicates ##maybe not necessary anymore READ_results_ID &lt;- distinct(READ_results_ID) Lets have a closer look at the samples that were sequenced twice #find samples that were sequenced twice duplicates &lt;- filter(READ_results_ID, ID_a == ID_b) #average relatedness of these duplicted inidividuals mean(duplicates$NonNormalizedP0) #&gt; [1] NaN #range range(duplicates$NonNormalizedP0) #&gt; Warning in min(x): kein nicht-fehlendes Argument für min; gebe Inf zurück #&gt; Warning in max(x): kein nicht-fehlendes Argument für max; gebe -Inf zurück #&gt; [1] Inf -Inf We also include the group information #first include group of individual a READ_results_sample_info &lt;- left_join(READ_results_ID, sample_info, by = c(&quot;ID_a&quot; = &quot;ID&quot;)) #rename &quot;Group_ID&quot; to &quot;a_Group&quot; READ_results_sample_info &lt;- rename(READ_results_sample_info, &quot;a_Group&quot; = &quot;Group_ID&quot;) READ_results_sample_info &lt;- rename(READ_results_sample_info, &quot;a_sex&quot; = &quot;sex&quot;) #then include group of individual b READ_results_sample_info &lt;- left_join(READ_results_sample_info, sample_info, by = c(&quot;ID_b&quot; = &quot;ID&quot;)) READ_results_sample_info &lt;- rename(READ_results_sample_info, &quot;b_sex&quot; = &quot;sex&quot;) #rename &quot;Group_ID&quot; to &quot;b_Group&quot; READ_results_sample_info &lt;- rename(READ_results_sample_info, &quot;b_Group&quot; = &quot;Group_ID&quot;) #create new column that specifies if individuals are from same or different groups READ_results_sample_info &lt;- READ_results_sample_info %&gt;% mutate(dyad_group = case_when(ID_a == ID_b ~ &quot;identical&quot;, a_Group == b_Group ~ &quot;intragroup&quot;, a_Group != b_Group ~ &quot;intergroup&quot;)) unique(READ_results_sample_info$dyad_group) #&gt; [1] &quot;intergroup&quot; &quot;intragroup&quot; #create new column that specifies if individuals have same or different sex READ_results_sample_info &lt;- READ_results_sample_info %&gt;% mutate(dyad_sex = case_when(ID_a == ID_b ~ &quot;identical&quot;, a_sex == b_sex ~ &quot;same sex&quot;, a_sex != b_sex ~ &quot;male-female&quot;)) #recode dyads for individuals with undetermined sex to NA READ_results_sample_info$dyad_sex[READ_results_sample_info$a_sex == &quot;u&quot;] &lt;- NA READ_results_sample_info$dyad_sex[READ_results_sample_info$b_sex == &quot;u&quot;] &lt;- NA #recode same sex dyads to male or female READ_results_sample_info$dyad_sex[READ_results_sample_info$dyad_sex == &quot;same sex&quot; &amp; READ_results_sample_info$a_sex == &quot;f&quot;] &lt;- &quot;female&quot; READ_results_sample_info$dyad_sex[READ_results_sample_info$dyad_sex == &quot;same sex&quot; &amp; READ_results_sample_info$a_sex == &quot;m&quot;] &lt;- &quot;male&quot; unique(READ_results_sample_info$dyad_sex) #&gt; [1] NA &quot;male-female&quot; &quot;male&quot; &quot;female&quot; theme_set(theme_classic()) #plot relatedness P0 (y-axis) for every dyad (x-axis), ordered from low to high relatedness and colored according to inter- or intragroup dyad ggplot(READ_results_sample_info, aes(x = reorder(PairIndividuals, NonNormalizedP0), y = NonNormalizedP0, color = dyad_sex)) + geom_point(alpha = 0.1, aes(y = NonNormalizedP0)) + #plot relatedness estimates as points labs( x = &quot;Dyad&quot;, y = &quot;Relatedness (READ)&quot;) theme_set(theme_classic()) #plot relatedness pi_HAT (y-axis) for the different categories of sex of dyad (x-axis) colored according to group membership ggplot(READ_results_sample_info, aes(x = dyad_sex, y = NonNormalizedP0, color = dyad_group)) + geom_point(alpha = 0.2) + geom_boxplot() ggtitle(&quot;relatedness (READ)&quot;) #&gt; $title #&gt; [1] &quot;relatedness (READ)&quot; #&gt; #&gt; attr(,&quot;class&quot;) #&gt; [1] &quot;labels&quot; 4.3.2.4 Combined relatedness results merge ngsrelate and lcmlkin relate_results &lt;- full_join(ngsRelate_results_sample_info, lcmlkin_results_sample_info, by = &quot;RGSM_dyad&quot;) relate_results &lt;- full_join(relate_results, READ_results_sample_info, by = &quot;RGSM_dyad&quot;) plot theme_set(theme_classic()) #plot relatedness pi_HAT and rab (y-axis) for every dyad (x-axis), ordered from low to high relatedness and colored according to inter- or intragroup dyad ggplot(filter(relate_results, coverage &gt; 0.85), aes(x = reorder(dyad, pi_HAT), color = dyad_sex)) + scale_colour_viridis_d() + geom_point(alpha = 0.5, aes(y = pi_HAT), shape = 15) + #plot lcmlkin relatedness estimates as points geom_point(alpha = 0.5, aes(y = 0.7-NonNormalizedP0), shape = 16) + #plot READ estimate geom_point(alpha = 0.5, aes(y = rab), shape = 17) + # plot ngsRelate estimates scale_y_continuous( name = &quot;relatedness (lcmlkin)&quot;, #features of first axis sec.axis = sec_axis(~., name = &quot;P0&quot;) #features of second axis ) + ggtitle(&quot;Comparison of relatedness estimators (&gt;0.85X)&quot;) #&gt; Warning: Removed 28 rows containing missing values (geom_point). #&gt; Warning: Removed 28 rows containing missing values (geom_point). #&gt; Warning: Removed 28 rows containing missing values (geom_point). Compare correlation among the three estimators ggplot(relate_results, aes(x = rab, y = pi_HAT, color = dyad_sex, size = nSites, shape = dyad_group.x)) + scale_colour_viridis_d() + geom_point(alpha = 0.2) #&gt; Warning: Removed 374 rows containing missing values (geom_point). ggplot(relate_results, aes(x = rab, y = NonNormalizedP0, color = dyad_sex, size = nSites, shape = dyad_group.x)) + scale_colour_viridis_d() + geom_point(alpha = 0.2) #&gt; Warning: Removed 374 rows containing missing values (geom_point). ggplot(relate_results, aes(x = pi_HAT, y = NonNormalizedP0, color = dyad_sex, size = nSites, shape = dyad_group.x)) + scale_colour_viridis_d() + geom_point(alpha = 0.2) #&gt; Warning: Removed 374 rows containing missing values (geom_point). Have a closer look at the groups ggplot(filter(relate_results, dyad_group == &quot;intragroup&quot;), aes(x = dyad_sex, y = rab, color = dyad_sex)) + scale_color_viridis_d() + geom_point(alpha = 0.2, position = position_dodge(0.5)) + geom_boxplot(alpha = 0.4, outlier.shape = NA) + facet_grid(.~a_Group) #&gt; Warning: Removed 34 rows containing missing values (geom_point). For comparison of relatedness estimators check Yaka et al. 2021 Curr Biol. "],["analysis.html", "5 Analysis 5.1 Setup 5.2 Data overview 5.3 Analysis 2", " 5 Analysis 5.1 Setup library(tidyverse) #&gt; -- Attaching packages ---------------------------------------------------------------------- tidyverse 1.3.0 -- #&gt; v ggplot2 3.3.2 v purrr 0.3.4 #&gt; v tibble 3.0.3 v dplyr 1.0.2 #&gt; v tidyr 1.1.2 v stringr 1.4.0 #&gt; v readr 1.3.1 v forcats 0.5.0 #&gt; -- Conflicts ------------------------------------------------------------------------- tidyverse_conflicts() -- #&gt; x dplyr::filter() masks stats::filter() #&gt; x dplyr::lag() masks stats::lag() library(ggplot2) library(ggthemes) library(ggforce) library(ggridges) library(ggsci) library(wesanderson) library(gghighlight) 5.2 Data overview An overview of the samples as of 26th April 2021 is stored in Guineafowl-lcWGS_DataOverview_20210426.csv. This is needed to later assign the relatedness estimates to specific individuals sample_overview &lt;- read.csv(&quot;vignettes/data/Guineafowl-lcWGS_DataOverview_20210426.csv&quot;, header = TRUE, sep = &quot;;&quot;, as.is = TRUE) str(sample_overview) #&gt; &#39;data.frame&#39;: 119 obs. of 17 variables: #&gt; $ individual : chr &quot;W1398&quot; &quot;W1429&quot; &quot;W1429&quot; &quot;W1502&quot; ... #&gt; $ library : chr &quot;L16926&quot; &quot;L16927&quot; &quot;L16927&quot; &quot;L16928&quot; ... #&gt; $ run : chr &quot;S2&quot; &quot;S1&quot; &quot;S3&quot; &quot;S4&quot; ... #&gt; $ original.o..resequenced.r. : chr &quot;o&quot; &quot;r&quot; &quot;o&quot; &quot;o&quot; ... #&gt; $ readGroupID : int 4 5 4 4 4 5 4 4 4 4 ... #&gt; $ total.reads : int 6720264 21332072 6069840 13390576 12081324 11995744 5684766 7759668 12174890 11373232 ... #&gt; $ trim.input.reads : int 3360132 10666036 3034920 6695288 6040662 5997872 2842383 3879834 6087445 5686616 ... #&gt; $ trim.reads.survived.both : int 2544284 9427764 2360036 5279275 4602830 5309238 2225803 2852960 4754568 4400910 ... #&gt; $ trim.reads.dropped.... : num 0.24 0.12 0.22 0.21 0.24 0.11 0.22 0.26 0.22 0.23 ... #&gt; $ mapped.reads : int 4987783 18494700 4631339 10376967 9021788 10412331 4367512 5598370 9342782 8636957 ... #&gt; $ mapped.reads.... : num 98 98.1 98.1 98.3 98 ... #&gt; $ coverage.mean : num 0.56 2.06 0.52 1.14 0.97 1.14 0.48 0.63 1.05 0.98 ... #&gt; $ coverage.st.dev. : num 2.48 4.96 2.58 2.8 3.81 3.56 2.18 2.43 2.58 3.13 ... #&gt; $ Duplicates.... : num 5.07 8.13 4.92 5.2 5.09 9.35 5.56 4.54 4.59 4.84 ... #&gt; $ Lib.complexity.total.reads : int 2250000 8750000 2250000 5000000 4250000 4750000 2000000 2750000 4500000 4250000 ... #&gt; $ Lib.complexity.distinct.reads: int 2224740 8608220 2221360 4963340 4181270 4688400 1979850 2722780 4466910 4203570 ... #&gt; $ number.of.snps : logi NA NA NA NA NA NA ... 5.3 Analysis 2 "],["references-and-session-info.html", "6 References and Session Info 6.1 Session Info 6.2 References", " 6 References and Session Info 6.1 Session Info sessionInfo() #&gt; R version 3.6.3 (2020-02-29) #&gt; Platform: x86_64-w64-mingw32/x64 (64-bit) #&gt; Running under: Windows 10 x64 (build 18363) #&gt; #&gt; Matrix products: default #&gt; #&gt; locale: #&gt; [1] LC_COLLATE=German_Germany.1252 LC_CTYPE=German_Germany.1252 #&gt; [3] LC_MONETARY=German_Germany.1252 LC_NUMERIC=C #&gt; [5] LC_TIME=German_Germany.1252 #&gt; #&gt; attached base packages: #&gt; [1] stats graphics grDevices utils datasets methods base #&gt; #&gt; other attached packages: #&gt; [1] bookdown_0.21 #&gt; #&gt; loaded via a namespace (and not attached): #&gt; [1] compiler_3.6.3 magrittr_1.5 htmltools_0.5.0 tools_3.6.3 #&gt; [5] yaml_2.2.1 stringi_1.4.6 rmarkdown_2.6 knitr_1.30 #&gt; [9] stringr_1.4.0 digest_0.6.25 xfun_0.17 rlang_0.4.7 #&gt; [13] evaluate_0.14 6.2 References "]]
